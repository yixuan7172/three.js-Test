<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rain</title>
    <script src="../assets/js/three.js"></script>
    <script src="../assets/js/renderers/CanvasRenderer.js"></script>
    <script src="../assets/js/physijs/physi.js"></script>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<script>
    'use strict'
    Physijs.scripts.worker = '../assets/js/physijs/physijs_worker.js'
    Physijs.scripts.ammo = '../assets/js/physijs/ammo.js'
    let camera, renderer, scene, mesh
    let aspect = window.innerWidth / window.innerHeight
    let path     = './img/',
        textures = [
            path + '1.png', path + '2.png', path + '3.png',
            path + '4.png', path + '5.png', path + '6.png',
            path + '7.png', path + '8.png', path + '9.png'
        ]
    let cubes = []
    let loader = new THREE.TextureLoader()
    let startPos = new THREE.Vector3(toRandom(-30, 30), toRandom(-10, 10) + 20, toRandom(-5, 5))
    let speed       = [0.35, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1],//下落速度
        rotateSpeed = [0.025, 0.05, 0.08, 0.02, 0.01, 0.06, 0.07, 0.75]//旋转速度

    function init() {
        scene = new Physijs.Scene
        scene.setGravity(new THREE.Vector3(0, -10, 0))
        scene.background = new THREE.Color(0xffffff)
        renderer = new THREE.WebGLRenderer({antialias: true})
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)
        camera = new THREE.PerspectiveCamera(45, aspect, 1, 1000)
        camera.position.z = 80
        for(let i = 0, il = textures.length; i < il; ++i) {
            let texture = loader.load(textures[i]),
                geo     = new THREE.BoxGeometry(3, 3, 3),
                mat     = new THREE.MeshBasicMaterial({map: texture})
            mesh = new THREE.Mesh(geo, mat)
            scene.add(mesh)
            cubes.push(mesh)
            //初始化cubes状态
            cubes[i].scale.x = cubes[i].scale.y = cubes[i].scale.z = toRandom(0.5, 1)
            cubes[i].position.x = toRandom(-30, 30)
            cubes[i].position.y = toRandom(-80, 80) + 130
            cubes[i].position.z = toRandom(-5, 5)
        }
        render()
    }

    function render() {
        requestAnimationFrame(render)
        renderer.render(scene, camera)
        drop()
    }

    function toRandom(min, max) {
        if(max < min) return
        return min + Math.random() * (max - min)
    }

    function drop() {
        for(let i = 0; i < cubes.length; i++) {
            cubes[i].rotation.x += rotateSpeed[~~Math.random() * 8]
            cubes[i].rotation.y += rotateSpeed[~~Math.random() * 8]
            cubes[i].position.y -= speed[~~Math.random() * 9]
        }
        resetState()
    }

    function resetState() {
        for(let i = 0; i < cubes.length; i++) {
            if(cubes[i].position.y < -60) {
                cubes[i].scale.x = cubes[i].scale.y = cubes[i].scale.z = toRandom(0.5, 1)
                cubes[i].position.x = toRandom(-30, 30)
                cubes[i].position.y = toRandom(-80, 80) + 130
                cubes[i].position.z = toRandom(-5, 5)

                // cubes[i].rotation.x += rotateSpeed[~~Math.random() * 8]
                // cubes[i].rotation.y += rotateSpeed[~~Math.random() * 8]
                // cubes[i].position.y -= speed[~~Math.random() * 9]
            }
        }
    }

    window.onresize = function() {
        camera.aspect = aspect
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
    }
    init()
</script>
</body>
</html>